

\section{Algorithms}

\begin{definition}[Finite-State Automata]
	\label{def:Finite-State Automata}
    %\lean{FSA}
    %\leanok 
	todo
\end{definition}

\begin{definition}[Context-Free Grammar]
	\label{def:Context-Free Grammar}
    %\leanok
	todo
\end{definition}

\begin{definition}[Finite-State Transducer]
	\label{def:Finite-State Transducer}
    %\lean{FST}
    %\leanok 
	\uses{def:Finite-State Automata}
	todo
\end{definition}

\begin{definition}[Pushdown Automata]
	\label{def:Pushdown Automata}
	todo
\end{definition}

\begin{definition}[Checker]
    \label{def:Checker}
    todo
\end{definition}

\begin{definition}[ConstrainedDecoding]
    \label{def:ConstrainedDecoding}
    \uses{def:LanguageModel, def:Checker}
    \[
    \begin{array}{l}
    \textbf{Algorithm: ConstrainedDecoding} \\
    \textbf{Input: } \text{Model } M, \text{Checker } C, \text{Tokenized prompt } x \\
    \mathcal{V} := M.\texttt{vocabulary} \\
    \textbf{repeat} \\
    \quad m := C(x; \mathcal{V}) \\
    \quad \textit{logits} := M(x) \\
    \quad t_{\text{next}} := \texttt{sample}(\texttt{applyMask}(m, \textit{logits})) \\
    \quad x := x.\texttt{append}(t_{\text{next}}) \\
    \textbf{until } t_{\text{next}} \ne \texttt{EOS} \\
    \textbf{return } x \\
    \end{array}
    \]
\end{definition}

\begin{definition}[Partial Lexer]
    \label{def:Partial Lexer}
    todo
\end{definition}

\begin{definition}[Lexing Transducer]
    \label{def:Lexing Transducer}
    todo
\end{definition}

\begin{definition}[BuildLexingFST]
    \label{def:BuildLexingFST}
    \uses{def:Finite-State Automata, def:Lexing Transducer}
    todo
\end{definition}

\begin{theorem}[Lexing Transducer Equivalent to \texttt{Lex}]
    \label{def:Lexing Transducer Equivalent}
    \uses{def:Lexing Transducer, def:Partial Lexer}
    Let \(\mathcal{T}_A = (Q, \Sigma, \Gamma, q_0, \delta, F)\) be a lexing transducer for the lexer specification \(\{(\mathcal{A}^i, T^i)\}_i\). Then 
\[
    q_0 \xrightarrow{w : T_1 \ldots T_k}{}^* q' \in \delta^* \quad \text{if and only if} \quad \texttt{Lex}(w) = (T_1 \ldots T_k, w_r)
    \]
    for some \(w_r \in \Sigma^*\) and \(q' \in Q\) such that \(q_0 \xrightarrow{w_r : \epsilon}{}^* q'\).
\end{theorem}

\begin{definition}[LanguageModel]
    \label{def:LanguageModel}
    todo
\end{definition}

\begin{definition}[Detokenizer]
    \label{def:Detokenizer}
    todo
\end{definition}

\begin{definition}[BuildDetokenizingFST]
    \label{def:BuildDetokenizingFST}
    \uses{def:Finite-State Transducer, def:Detokenizer}
    todo
\end{definition}

\begin{definition}[Parser]
    \label{def:Parser}
    todo
\end{definition}

\begin{definition}[PreprocessParser]
    \label{def:PreprocessParser}
    \uses{def:Pushdown Automata, def:Parser}
    todo
\end{definition}